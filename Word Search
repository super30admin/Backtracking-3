// TC - O((m * n) 3^(L)) where m - no of rows, n - no of cols, L - length of word
// SC - we will use inplace modification instead of visited array = O(L) where L - length of word

class Solution {
    int[][] dirs;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board == null)
            return false;
        
        int m = board.length, n = board[0].length;
        dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
        
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                
                if(backtrack(board, i, j, word, 0))
                    return true;
            }
        }
        return false;
    }
    
    public boolean backtrack(char[][] board, int i, int j, String word, int charIndex)
    {
        // base case
        if(charIndex == word.length())
            return true;
        
        if(i < 0 || j < 0 || i == board.length || j == board[0].length || board[i][j] == '#')
            return false;
        
        // logic
        if(board[i][j] == word.charAt(charIndex))
        {
            //action 
            char c = board[i][j];
            board[i][j] = '#';
                
            // recurse
            for(int[] dir: dirs)
            {
                int row = dir[0] + i;
                int col = dir[1] + j;
                if(backtrack(board, row, col, word, charIndex + 1))
                    return true;
            }
            
            // backtrack
            board[i][j] = c;
        }
        return false;
    }
}

